## 프로세스
 - (Process Control Block, PCB)
    - PID
    - Status
    - Priority
    - PC 


## CPU 스케줄러

*스케줄링 대상은 Ready Queue에 있는 프로세스들이다.*

### FCFS(First Come First Served)

#### 특징

- 먼저 온 고객을 먼저 서비스해주는 방식, 즉 먼저 온 순서대로 처리.
- 비선점형(Nonpreemtive) 스케줄링
  일단 CPU를 잡으면 CPU burst가 완료될 때까지 CPU를 반환하지 않는다. 할당되었던 CPU가 반환될 때만 스케줄링이 이루어진다.

#### 문제점

- convoy effect
  소요시간이 긴 프로세스가 먼저 도달하여 효율성을 낮추는 현상이 발생한다.

### SJF(Shortest - Job - First)

#### 특징

- 다른 프로세스가 먼저 도착했어도 CPU burst time이 짧은 프로세스에게 선 할당
- 비선점형(Nonpreemtive) 스케줄링

#### 문제점

- starvation 효율성을 추구하는게 가장 중요하지만 특정 프로세스가 지나치게 차별받으면 안되는 것이다. 이 스케줄링은 극단적으로 CPU사용이 짧은 job을 선호한다. 그래서 사용 시간이 긴 프로세스는 거의 영원히 CPU를 할당받을 수 없다.

### SRT(Shortest Remaining time First)

#### 특징

- 새로운 프로세스가 도착할 때마다 새로운 스케줄링이 이루어진다.
- 선점형 (preemtive) 스케줄링
  현재 수행중인 프로세스의 남은 burst time보다 더 짧은 CPU burst time을 가지는 새로운 프로세스가 도착하면 CPU를 뺏긴다.

#### 문제

- starvation
- 새로운 프로세스가 도달할 때마다 스케줄링을 다시하기 때문에 CPU burst time(CPU 사용시간)을 측정할 수가 없다.

### Priority Scheduling

#### 특징

- 우선순위가 가장 높은 프로세스에게 CPU를 할당하겠다. 우선순위란 정수로 표현하게 되고 작은 숫자가 우선순위가 높다.
- 선점형 스케줄링
  더 높은 우선순위의 프로세스가 도착하면 뺏는다.

#### 문제점

- starvation

#### 해결책

- aging
  아무리 우선순위가 낮은 프로세스라도 오래 기다리면 우선순위를 높여주자.

### Round Robin

#### 특징

- 현대적인 CPU 스케줄링
- 각 프로세스는 동일한 크기의 할당 시간(time quantum)을 갖게 된다.
- 할당 시간이 지나면 프로세스는 선점당하고 ready queue의 제일 뒤에 가서 다시 줄을 선다.
- `RR`은 CPU사용시간이 랜덤한 프로세스들이 섞여있을 경우에 효율적
- `RR`이 가능한 이유는 프로세스의 context를 save할 수 있기 때문이다.

#### 장점

- `Response time`이 빨라진다.
  n개의 프로세스가 ready queue에 있고 할당시간이 q(time quantum)인 경우 각 프로세스는 q단위로 CPU시간의 1/n을 얻는다. 즉, 어떤 프로세스도 (n-1)q time unit 이상 기다리지 않는다.
- 프로세스가 기다리는 시간이 CPU를 사용할 만큼 증가한다.
  공정한 스케줄링이라고 할 수 있다.







### Deadlock

\- 영원히 오지않는 이벤트를 기다리는 것 (응답없음 상태같은;)

\- A라는 프로세스는 B가 가진 자원 있어야 동작 가능하다, 그래서 B 작업이 끝나서 자원을 넘겨주기를 기다리고 있는데    B라는 프로세스 역시 A가 가진 자원이 있어야 있어야 하기 때문에 A작업이 끝나기만을 기다리는 상태.

즉 무한 교착 상태를 말한다. ( 두 작업은 영원히 끝날 수 없다)





**발생조건 **

- 상호배제 :  자원은 한 번에 한 프로세스만이 사용할 수 있어야 한다.
- 점유 및 대기 : 
- 비선점
- 환형대기

위 네 조건중 하나라도 성립하지 않으면 교착상태를 해결할 수 있다.



**해결**

- 교착 상태 회피 : **은행가 알고리즘(Banker's algorithm)** , 프로세스가 자원을 요구할 때 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지를 사전에 검사하여 교착 상태를 회피 

 [이외 해결방안](http://includestdio.tistory.com/12)





#### Thread와 Process의 차이 

process는 완벽히 독립적이기 때문에 메모리 영역(Code, Data, Heap, Stack)을 다른 프로세스와 공유하지 않는다. thread 해당 thread를 위한 스택을 생성할 뿐 그 이외의 Code, Data, Heap영역을 공유한다.

* 참고 (메모리 영역)
  -  Code : **코드 자체**
  -  Data : **전역변수(global)**, **정적변수(static)**
  -  Heap : **동적할당**
  -  Stack : **지역변수(local)**, **매개변수(parameter)**, **리턴 값**



#### 멀티 프로세스와 멀티 스레드 차이

- 멀티 프로세스
  - fork를 통해 프로세스를 복사한다.
  - 프로세스 간의 통신을 하려면 IPC(Inter Process Communication; 세마포어, 큐, 공유메모리)를 통해야 한다. 
- 멀티 스레드
  - 하나의 프로세스가 다수 개의 작업을 각각 스레드를 이용하여 동시에 작동 시킬 수 있다. 
  - 멀티프로세스에 비해 좋음 -> 하지만 안전성과 효율성에 문제 있을 수도 ,여러 개의 스레드가 동일한 데이터 공간을 공유하면서 이들을 수정한다는 점에 필연적으로 생기는 문제이다. 멀티 프로세스의 방식의 프로그램에서 하나의 프로세스가 자신의 데이터 공간을 망가뜨린다면 그것은 해당 프로세스의 중단을 낳게 될 것이다. 하지만 멀티 스레드 방식의 프로그램에서는 하나의 스레드가 자신이 사용하던 데이터 공간을 망가뜨린다면 그 결과는 하나의 데이터 공간을 공유하는 모든 스레드를 작동불능 상태로 만들어 버릴 것이다. -> 이러한 문제에 대비하기 위해 Critical Section 기법이 존재한다. 
  - 그렇기 때문에 멀티스레딩 환경에서는 동기화 작업이 필요하다. 동기화를 통해 작업 처리 순서를 컨트롤 하고 공유 자원에 대한 접근을 컨트롤 하는 것이다. 하지만 이로 인해 병목현상이 발생하여 성능이 저하될 가능성이 높다. 그러므로 과도한 락으로 인한 병목현상을 줄여야 한다.





#### 가상메모리

- 메모리보다 큰 프로그램을 실행하려면? 가상메모리 이용

  [내부 단편화& 외부 단편화](http://raisonde.tistory.com/entry/%EB%82%B4%EB%B6%80%EB%8B%A8%ED%8E%B8%ED%99%94%EC%99%80-%EC%99%B8%EB%B6%80%EB%8B%A8%ED%8E%B8%ED%99%94-%EC%A0%95%EB%A7%90-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EC%9E%90)

- 가상메모리

  - 세그먼트 기법 =>단점: 외부단편화
  - 페이징 => 단점 : 내부단편화 
