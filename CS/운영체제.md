# OS

- 듀얼 모드 
  - 유저 모드  
  - 커널 모드   
- 모드를 나눈 이유 : 사용자 프로그램이 실행되면서 자신의 프로그램이 있는 영역을 벗어나 다른 사용자 영역에 대해 쓰기 작업을 하거나 심지어 운영체제가 깔려 있는 영역으로 뭔가를 변경시켜 버리는 일을 하지 못하도록 하기 위해서
- 유저 모드실행 중 커널 모드에서 해야 할 일이 생기면 프로그램은 **시스템콜**을 함

## 프로세스

> 수행 중인 프로그램,  즉 디스크와 같은 보조기억 장치에 단순히 저장되어 있는 프로그램은 프로세스가 아니란 말이다. 

 - 프로세스제어블록(Process Control Block, PCB)

    > 운영체제가 프로세스에 대한 중요한 정보를 저장하는 곳, 각 프로세스가 생성 될 때마다 고유의 PCB가 생성, 프로세스가 종료되면 PCB는 제거 

    - PID
    - Status
    - Priority
    - PC

- 문맥 교환 (Context Switching)

    ![Alt text](./Img/Switching.PNG)

    ​


## CPU 스케줄러

*스케줄링 대상은 Ready Queue에 있는 프로세스들이다.*

### FCFS(First Come First Served)

#### 특징

- 먼저 온 고객을 먼저 서비스해주는 방식, 즉 먼저 온 순서대로 처리.
- 비선점형(Nonpreemtive) 스케줄링
  일단 CPU를 잡으면 CPU burst가 완료될 때까지 CPU를 반환하지 않는다. 할당되었던 CPU가 반환될 때만 스케줄링이 이루어진다.

#### 문제점

- convoy effect
  소요시간이 긴 프로세스가 먼저 도달하여 효율성을 낮추는 현상이 발생한다.

### SJF(Shortest - Job - First)

#### 특징

- 다른 프로세스가 먼저 도착했어도 CPU burst time이 짧은 프로세스에게 선 할당
- 비선점형(Nonpreemtive) 스케줄링

#### 문제점

- starvation 효율성을 추구하는게 가장 중요하지만 특정 프로세스가 지나치게 차별받으면 안되는 것이다. 이 스케줄링은 극단적으로 CPU사용이 짧은 job을 선호한다. 그래서 사용 시간이 긴 프로세스는 거의 영원히 CPU를 할당받을 수 없다.

### SRT(Shortest Remaining time First)

#### 특징

- 새로운 프로세스가 도착할 때마다 새로운 스케줄링이 이루어진다.
- 선점형 (preemtive) 스케줄링
  현재 수행중인 프로세스의 남은 burst time보다 더 짧은 CPU burst time을 가지는 새로운 프로세스가 도착하면 CPU를 뺏긴다.

#### 문제

- starvation
- 새로운 프로세스가 도달할 때마다 스케줄링을 다시하기 때문에 CPU burst time(CPU 사용시간)을 측정할 수가 없다.

### Priority Scheduling

#### 특징

- 우선순위가 가장 높은 프로세스에게 CPU를 할당하겠다. 우선순위란 정수로 표현하게 되고 작은 숫자가 우선순위가 높다.
- 선점형 스케줄링
  더 높은 우선순위의 프로세스가 도착하면 뺏는다.

#### 문제점

- starvation

#### 해결책

- aging
  아무리 우선순위가 낮은 프로세스라도 오래 기다리면 우선순위를 높여주자.

### Round Robin

#### 특징

- 현대적인 CPU 스케줄링
- 각 프로세스는 동일한 크기의 할당 시간(time quantum)을 갖게 된다.
- 할당 시간이 지나면 프로세스는 선점당하고 ready queue의 제일 뒤에 가서 다시 줄을 선다.
- `RR`은 CPU사용시간이 랜덤한 프로세스들이 섞여있을 경우에 효율적
- `RR`이 가능한 이유는 프로세스의 context를 save할 수 있기 때문이다.

#### 장점

- `Response time`이 빨라진다.
  n개의 프로세스가 ready queue에 있고 할당시간이 q(time quantum)인 경우 각 프로세스는 q단위로 CPU시간의 1/n을 얻는다. 즉, 어떤 프로세스도 (n-1)q time unit 이상 기다리지 않는다.
- 프로세스가 기다리는 시간이 CPU를 사용할 만큼 증가한다.
  공정한 스케줄링이라고 할 수 있다.







### Deadlock

\- 영원히 오지않는 이벤트를 기다리는 것 (응답없음 상태같은;)

\- A라는 프로세스는 B가 가진 자원 있어야 동작 가능하다, 그래서 B 작업이 끝나서 자원을 넘겨주기를 기다리고 있는데    B라는 프로세스 역시 A가 가진 자원이 있어야 있어야 하기 때문에 A작업이 끝나기만을 기다리는 상태.

즉 무한 교착 상태를 말한다. ( 두 작업은 영원히 끝날 수 없다)





**발생조건 **

- 상호배제 :  자원은 한 번에 한 프로세스만이 사용할 수 있어야 한다.
- 점유 및 대기 : 
- 비선점
- 환형대기

위 네 조건중 하나라도 성립하지 않으면 교착상태를 해결할 수 있다.



**해결**

- 교착 상태 회피 : **은행가 알고리즘(Banker's algorithm)** , 프로세스가 자원을 요구할 때 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지를 사전에 검사하여 교착 상태를 회피 

 [이외 해결방안](http://includestdio.tistory.com/12)



## Thread

#### 종류

- Kernel level thread :  
  - 커널에 의해 관리, 스레드 대기시 해당 프로세스의 다른 스레드가 실행 가능 
  - 같은 프로세스 내 스레드간 스위칭도 커널의 개입이 필요( 모드 스위칭 발생)
- User level thread :  
  - 스레드 라이브러리에 의해 관리
  - 스레드와 관련된 모든 행위는 사용자 공간에서 이루어지므로 커널은 스레드의 존재를 알지 못함, 커널은 그 스레드가 속한 프로세스로 인식(단점:  스레드 대기 = 프로세스 대기 )
  - 사용자 레벨 스레드는 스레드 스위칭에 커널의 개입이 필요 없음

#### Thread와 Process의 차이 

process는 완벽히 독립적이기 때문에 메모리 영역(Code, Data, Heap, Stack)을 다른 프로세스와 공유하지 않는다. thread 해당 thread를 위한 스택을 생성할 뿐 그 이외의 Code, Data, Heap영역을 공유한다.

* 참고 (메모리 영역)
  -  Code : **코드 자체**
  -  Data : **전역변수(global)**, **정적변수(static)**
  -  Heap : **동적할당**
  -  Stack : **지역변수(local)**, **매개변수(parameter)**, **리턴 값**



#### 멀티 프로세스와 멀티 스레드 차이

- 멀티 프로세스
  - fork를 통해 프로세스를 복사한다.
  - 프로세스 간의 통신을 하려면 IPC(Inter Process Communication; 세마포어, 큐, 공유메모리)를 통해야 한다. 
- 멀티 스레드
  - 하나의 프로세스가 다수 개의 작업을 각각 스레드를 이용하여 동시에 작동 시킬 수 있다. 
  - 멀티프로세스에 비해 좋음 -> 하지만 안전성과 효율성에 문제 있을 수도 ,여러 개의 스레드가 동일한 데이터 공간을 공유하면서 이들을 수정한다는 점에 필연적으로 생기는 문제이다. 멀티 프로세스의 방식의 프로그램에서 하나의 프로세스가 자신의 데이터 공간을 망가뜨린다면 그것은 해당 프로세스의 중단을 낳게 될 것이다. 하지만 멀티 스레드 방식의 프로그램에서는 하나의 스레드가 자신이 사용하던 데이터 공간을 망가뜨린다면 그 결과는 하나의 데이터 공간을 공유하는 모든 스레드를 작동불능 상태로 만들어 버릴 것이다. -> 이러한 문제에 대비하기 위해 Critical Section 기법이 존재한다. 
  - 그렇기 때문에 멀티스레딩 환경에서는 동기화 작업이 필요하다. 동기화를 통해 작업 처리 순서를 컨트롤 하고 공유 자원에 대한 접근을 컨트롤 하는 것이다. 하지만 이로 인해 병목현상이 발생하여 성능이 저하될 가능성이 높다. 그러므로 과도한 락으로 인한 병목현상을 줄여야 한다.


#### IPC

- Shared Memory

  > Shared Memory(공유 메모리)는 **프로세스간 메모리 영역을 공유해서 사용할 수 있도록 **허용합니다. 프로세스가 공유 메모리 할당을 커널에 요청하면 커널은 해당 프로세스에 메모리 공간을 할당해줍니다. 이후 어떤 프로세스건 해당 메모리영역에 접근할 수 있습니다.
  >
  > 공유메모리는 중개자가 없이 곧바로 메모리에 접근할 수 있기 때문에 다른 모든 **IPC들 중에서 가장 빠르게 작동**할 수 있습니다.

- Message Queue

  >  Queue(큐)는 선입선출의 자료구조를 가지는 통신설비로 커널에서 관리, 장점은 컨테이너 벨트가 가지는 장점을 그대로 가지게 됩니다. 컨테이너 벨트에 올라올 물건에 라벨을 붙이면 동시에 다양한 물건을 다룰 수 있는 것과 같이, **메시지 큐에 쓸 데이터에 번호를 붙임**으로써 여러 개의 프로세스가 동시에 데이터를 쉽게 다룰 수 있습니다.


#### 가상메모리

- 메모리보다 큰 프로그램을 실행하려면? 가상메모리 이용

  [내부 단편화& 외부 단편화](http://raisonde.tistory.com/entry/%EB%82%B4%EB%B6%80%EB%8B%A8%ED%8E%B8%ED%99%94%EC%99%80-%EC%99%B8%EB%B6%80%EB%8B%A8%ED%8E%B8%ED%99%94-%EC%A0%95%EB%A7%90-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EC%9E%90) 

- 가상메모리

  - 세그먼트 기법 =>단점: 외부단편화 (서로 다른 크기 단위)

    - ​

  - 페이징 => 단점 : 내부단편화  (서로 같은 크기 단위) , 페이지테이블은 메모리에 존재

    - TLB : 고속 캐시의 일종, 페이지 테이블을 메모리에 두고 접근할 떄의 느림을 극복하기 위해 사용. 페이지 테이블은 메모리에 있으니깐, 

    - 가상 주소 P값을 먼저 TLB부터 검색 -> TLB에 존재 -> 메모리에 접근 

      ​                                                            -> TLB에 없어 -> 페이지테이블에 접근 -> 페이지테이블에 존재 ->메모리 접근

      ​                                                                                                                              -> 페이지테이블에 없어->페이지 부재 
